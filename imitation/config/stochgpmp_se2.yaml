max_steps: 1000
output_dir: ./output


obs_horizon: 1

num_particles_per_goal: 10
num_samples: 64  # usually 64 samples is good enough for robot arm manipulation tasks
num_obst: 2
traj_len: 64
dt: 0.02   # this dt is very sensitive, 0.02 is good for 64 steps, then we fixed this and tuned for other params
start_pose: [1.0, 0.0, 0.0]
start_quat: [0.0, 0.0, 0.0, 1.0]
target_pose: [0.0, 1.0, 0.0] # target_rot fixed
seed: 0
opt_iters:  400

obstacles: [[[0.5, 0.5, 0.1, 0.1], [-0.5, -0.5, 0.1, 0.1]]]


# cost sigmas
sigma_self: 0.001
sigma_coll: 0.00001
sigma_goal: 0.0007
sigma_goal_prior: 0.01  # this joint space goal prior is usually just a suggestion. We set this cost scaling lower than the others so that task space costs are more relevant.
sigma_start: 0.001
sigma_gp: 0.07  # this gp prior is very sensitive, usually ranging from 0.05 - 0.1 is already good smoothness. There is a trade off between smoothness and collision avoidance prior, we should strive for balancing contribution of these two priors. 


stochgpmp_params:
  num_particles_per_goal: ${num_particles_per_goal}
  num_samples: ${num_samples}
  traj_len: ${traj_len}
  opt_iters: 1 # keep 1 for visualization
  temperature: 1.
  step_size: 0.5
  sigma_start_init: 0.001
  sigma_goal_init: 0.001
  sigma_gp_init: 5 # keep this less than 10! too noisy initialization degrade performance a lot, but a high enough variance is good for exploration
  sigma_start_sample: 0.001
  sigma_goal_sample: 0.001
  sigma_gp_sample: 2  # keep this less than 5! update should not be too noisy, but good enough for exploration
  seed: ${seed}
  # tensor_args: {device: cpu, dtype: float64}

env_runner: 
  _target_: imitation.env_runner.robomimic_lowdim_runner.RobomimicEnvRunner
  output_dir: ${output_dir}

planner:
  # other parameters (env and robot_fk) will be set on code
  _target_: imitation.utils.stochgpmp.StochGPMPSE2Wrapper
  seed: ${seed}